-- 1. Примените оконные функции к таблице products и с помощью ранжирующих функций упорядочьте
-- все товары по цене — от самых дорогих к самым дешёвым. Добавьте в таблицу следующие колонки:

-- Колонку product_number с порядковым номером товара (функция ROW_NUMBER).
-- Колонку product_rank с рангом товара с пропусками рангов (функция RANK).
-- Колонку product_dense_rank с рангом товара без пропусков рангов (функция DENSE_RANK).

-- Поля в результирующей таблице: product_id, name, price, product_number, product_rank, product_dense_rank
SELECT product_id,
       name,
       price,
       row_number() OVER (ORDER BY price desc) as product_number,
       rank() OVER (ORDER BY price desc) as product_rank,
       dense_rank() OVER (ORDER BY price desc) as product_dense_rank
FROM   products
-- ==================================================================================================================
-- 2. Примените оконную функцию к таблице products и с помощью агрегирующей функции в отдельной колонке
-- для каждой записи проставьте цену самого дорогого товара. Колонку с этим значением назовите max_price.
-- Затем для каждого товара посчитайте долю его цены в стоимости самого дорогого товара — просто поделите
-- одну колонку на другую. Полученные доли округлите до двух знаков после запятой. Колонку с долями назовите share_of_max.

-- Выведите всю информацию о товарах, включая значения в новых колонках.
-- Результат отсортируйте сначала по убыванию цены товара, затем по возрастанию id товара.
-- Поля в результирующей таблице: product_id, name, price, max_price, share_of_max

-- Пояснение:
-- В этой задаче окном выступает вся таблица. Сортировку внутри окна указывать не нужно.
-- С результатом агрегации по окну можно проводить арифметические и логические операции.
-- Также к нему можно применять и другие функции — например, округление, как в этой задаче.
SELECT product_id, name, price,
max(price) OVER () AS max_price,
ROUND(price / max(price) OVER (), 2) AS share_of_max
FROM products
ORDER BY price DESC, product_id
-- =================================================================================================================================
-- 3. Примените две оконные функции к таблице products — одну с агрегирующей функцией MAX,
-- а другую с агрегирующей функцией MIN — для вычисления максимальной и минимальной цены.
-- Для двух окон задайте инструкцию ORDER BY по убыванию цены. Поместите результат вычислений в две колонки max_price и min_price.

-- Выведите всю информацию о товарах, включая значения в новых колонках.
-- Результат отсортируйте сначала по убыванию цены товара, затем по возрастанию id товара.

-- Поля в результирующей таблице: product_id, name, price, max_price, min_price

-- После того как решите задачу, проанализируйте полученный результат и подумайте, почему получились именно такие расчёты.
-- При необходимости вернитесь к первому шагу и ещё раз внимательно ознакомьтесь с тем, как работает рамка окна при указании сортировки.
SELECT product_id, name, price,
max(price) OVER (ORDER BY price DESC) AS max_price,
min(price) OVER (ORDER BY price DESC) AS min_price
FROM products
ORDER BY price DESC, product_id
-- =====================================================================================================================================
-- 4. Сначала на основе таблицы orders сформируйте новую таблицу с общим числом заказов по дням.
-- При подсчёте числа заказов не учитывайте отменённые заказы (их можно определить по таблице user_actions).
-- Колонку с днями назовите date, а колонку с числом заказов — orders_count.

-- Затем поместите полученную таблицу в подзапрос и примените к ней оконную функцию в паре с агрегирующей функцией SUM
-- для расчёта накопительной суммы числа заказов. Не забудьте для окна задать инструкцию ORDER BY по дате.
-- Колонку с накопительной суммой назовите orders_cum_count. В результате такой операции значение накопительной
-- суммы для последнего дня должно получиться равным общему числу заказов за весь период.

-- Сортировку результирующей таблицы делать не нужно.
-- Поля в результирующей таблице: date, orders_count, orders_cum_count

SELECT date, orders_count,
SUM(orders_count) OVER (ORDER BY date) AS orders_cum_count
FROM(
    SELECT creation_time::DATE as date, count(product_ids) as orders_count
    FROM orders, user_actions
    WHERE orders.order_id = user_actions.order_id AND user_actions.action = 'create_order'
    GROUP BY creation_time::DATE
) t1

-- 5. Для каждого пользователя в таблице user_actions посчитайте порядковый номер каждого заказа. Для этого примените оконную функцию ROW_NUMBER
-- к колонке с временем заказа. Не забудьте указать деление на партиции по пользователям и сортировку внутри партиций. Отменённые заказы
-- не учитывайте. Новую колонку с порядковым номером заказа назовите order_number. Результат отсортируйте сначала по возрастанию id пользователя,
-- затем по возрастанию order_number. Добавьте LIMIT 1000.

-- Поля в результирующей таблице: user_id, order_id, time, order_number

SELECT user_id, order_id, time,
row_number() over (partition by user_id order by time) AS order_number
FROM user_actions
WHERE action = 'create_order'
ORDER BY user_id, order_number
limit 1000

-- 6. Дополните запрос из предыдущего задания и с помощью оконной функции для каждого заказа каждого пользователя рассчитайте,
-- сколько времени прошло с момента предыдущего заказа. 
-- Для этого сначала в отдельном столбце с помощью LAG сделайте смещение по столбцу time на одно значение назад.
-- Столбец со смещёнными значениями назовите time_lag. Затем отнимите от каждого значения в колонке time новое значение
-- со смещением (либо можете использовать уже знакомую функцию AGE). Колонку с полученным интервалом назовите time_diff.
-- Менять формат отображения значений не нужно, они должны иметь примерно следующий вид:
-- 3 days, 12:18:22

-- По-прежнему не учитывайте отменённые заказы. Также оставьте в запросе порядковый номер каждого заказа, рассчитанный на прошлом шаге.
-- Результат отсортируйте сначала по возрастанию id пользователя, затем по возрастанию порядкового номера заказа. Добавьте LIMIT 1000.
-- Поля в результирующей таблице: user_id, order_id, time, order_number, time_lag, time_diff

-- Пояснение:
-- Не забывайте про деление на партиции и сортировку внутри окна.
-- Также обратите внимание, что в результате смещения для первых заказов каждого пользователя в колонке time_lag получились
-- пропущенные значения. Для таких записей функция не нашла предыдущих значений и вернула NULL. То же самое произошло в записях
-- пользователей с одним заказом — внутри партиции с одной записью просто некуда сдвигаться.
-- Образовавшиеся пропущенные значения убирать из результата не нужно.

SELECT user_id, order_id, time, 
row_number() over (partition by user_id order by time) AS order_number,
lag(time) over (partition by user_id order by time) AS time_lag,
time - lag(time) over (partition by user_id order by time) AS time_diff
FROM user_actions
WHERE action = 'create_order'
ORDER BY user_id, order_number
limit 1000












